<html>
    <button onclick="calibrateGrav();">Calibrate Gravity</button>
    <canvas id="myCanvas"></canvas>
<script>
var cnvs = document.getElementById("myCanvas");
cnvs.width = window.innerWidth;
cnvs.height = window.innerHeight - 60;
var ctx = cnvs.getContext("2d");

window.screen.orientation.lock("portrait"); 

class vector3 {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    mag() {
        return Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2);
    }
}

class rotationMatrix {
    // alpha, beta, gamma in radians
    constructor(a, b, g) {
        this.a = a;
        this.b = b;
        this.g = g;

        this.ca = Math.cos(this.a);
        this.cb = Math.cos(this.b);
        this.cg = Math.cos(this.g);
        this.sa = Math.sin(this.a);
        this.sb = Math.sin(this.b);
        this.sg = Math.sin(this.g);

        // define each rotation matrix element
        this.rm = [3][3];
        this.rm[0][0] = ca * cb;
        this.rm[0][1] = ca * sb * sg - sa * cg;
        this.rm[0][2] = ca * sb * cg + sa * sg;
        this.rm[1][0] = sa * cb;
        this.rm[1][1] = sa * sb * sg + ca * cg;
        this.rm[1][2] = sa * sb * cg - ca * sg;
        this.rm[2][0] = -sb;
        this.rm[2][1] = cb * sg;
        this.rm[2][2] = cb * cg; 
    }

    // rotates v of type vector3
    rotateVector3(v) {
        v.x = this.rm[0][0] * v.x + this.rm[0][1] * v.y + this.rm[0][2] * v.z; 
        v.y = this.rm[1][0] * v.x + this.rm[1][1] * v.y + this.rm[1][2] * v.z; 
        v.z = this.rm[2][0] * v.x + this.rm[2][1] * v.y + this.rm[2][2] * v.z; 
    }
}

// vars
var gravCalibrated = false;
var grav = new vector3(0, 0, 0); // gravity vector
var rot = new vector3(0, 0, 0); // rotation in rads
var pos = new vector3(0, 0, 0); // position

var stepPrintY = 40;
var printY = stepPrintY;
function printData(context, label, data) {
    ctx.font = "40px Arial";

    var dataStr = "";
    if (typeof data == "object") {
        for (const p in data) {
            dataStr += data[p] + ", ";
        }

        // delete last comma
        dataStr = dataStr.slice(0, dataStr.length - 2);
    } else {
        dataStr = data;
    }

    context.fillText(label + dataStr, 20, printY);
    printY += stepPrintY;
}

// round the data from the IMU
function roundData(data) {
    var tmp = {};

    for (const p in data) {
        tmp[p] = Math.round(data[p] * 100) / 100;
    }

    return tmp;
}

function degreesToRads(data) {
    var tmp = {};

    for (const p in data) {
        tmp[p] = data[p] * Math.PI / 180;
    }

    return tmp;
}

// trackRotation takes the gyro data in radians and interval (delta time in milliseconds)
function trackRotation(g, dt) {
    rot.x += g.beta * dt/1000;
    rot.y += g.gamma * dt/1000;
    rot.z += g.alpha * dt/1000;
}

// get intitial gravity vector from average of stationary accelerometer samples
var gravSamples = 0;
var nGravSamples = 50;
function calibrateGrav(accelData) {
    gravCalibrated = false;

    // average gravity sample data
    grav.x += 1/(gravSamples + 1) * (accelData.x - grav.x);
    grav.y += 1/(gravSamples + 1) * (accelData.y - grav.y);
    grav.z += 1/(gravSamples + 1) * (accelData.z - grav.z);

    if (gravSamples < nGravSamples) {
        gravSamples++;
    } else {
        gravSamples = 0;
        gravCalibrated = true;
    }
}

// rotates the gravity vector so we can track in which direction
// we need to remove a vector of magnitude 9.81 to distinguish between
// gravitational acceleration and linear acceleration (acceleration caused by movement)
function rotateGravVector() {

}

function accelerometerUpdate(e) {
    ctx.clearRect(0, 0, cnvs.width, cnvs.height);
    printY = stepPrintY;

    // Note: these seem to only have 2 digits of precision
    // clone objects because event data read only 
    var accel = e.accelerationIncludingGravity;
    var gyro = e.rotationRate;
    var deltaTime = e.interval; 

    if (gravCalibrated == false) {
        calibrateGrav(accel);

        // dot animation
        var dots = "";
        for (var i = 0; i < gravSamples; i++)
            dots += ".";
        printData(ctx, "Calibrating Gravity", dots);

        return;
    }

    printData(ctx, "Grav Vector: ", roundData(grav));
    printData(ctx, "Grav Magnitude: ", grav.mag());

    gyro = degreesToRads(gyro);

    trackRotation(gyro, deltaTime);
    rotateGravVector(gyro, deltaTime);

    //The following two lines are to calculate tilt from grav vector.
    // var xPosition = Math.atan2(aY, aZ);
    // var yPosition = Math.atan2(aX, aZ);
    // ctx.fillText("tilt x: " + xPosition, 20, 200);
    // ctx.fillText("tilt y: " + yPosition, 20, 240);

    printData(ctx, "Accel: ", roundData(accel));

    // printData(ctx, "gX: ", gyro.beta);
    // printData(ctx, "gY: ", gyro.gamma);
    // printData(ctx, "gZ: ", gyro.alpha);

    printData(ctx, "dt: ", deltaTime);

    printData(ctx, "Rotation: ", roundData(rot));
}


//================ Event listeners ===============================

if (window.DeviceMotionEvent == undefined) {
    //No accelerometer is present. Use buttons. 
    alert("no accelerometer");
}
else {
    alert("accelerometer found");
    window.addEventListener("devicemotion", accelerometerUpdate, true);
}

</script>
</html>